
Overview
The Multithreaded Bank Transaction System is a client-server banking application that demonstrates the performance difference between single-threaded and multi-threaded request processing. This project was developed using C and POSIX threads (pthreads) on Ubuntu (WSL), featuring TCP socket communication, a thread pool architecture, and non-blocking I/O with epoll.

	The bank system has features such as:
Creating several bank accounts
Making deposits, withdrawals, and transfers
Runtime switching between single-threaded and multi-threaded modes
Built-in stress testing to measure throughput differences
Thread pool with task queue for parallel request processing
Per-account mutex locks for fine-grained synchronization


Motivation: Why Multi-Threading?

A bank server handling real transactions faces a fundamental problem: operations take time. Validating credentials, checking fraud rules, writing to databases, and logging for compliance all introduce latency—often 50-200ms per request.

In a single-threaded server, this latency is catastrophic:
- Client A sends a request, server blocks for 100ms processing
- Clients B, C, D wait in line doing nothing
- With 100 clients, the last one waits 10 seconds just to start

In a multi-threaded server with 10 workers:
- Clients A through J all process simultaneously
- Total time drops from sequential (100ms × N) to parallel (100ms × N/10)
- Throughput increases by 10× with the same hardware

This project demonstrates that difference with measurable benchmarks. The simulated 100ms delay in protocol.c represents real-world latency, and menu options 7 and 8 in the client let you toggle modes and see the throughput gap firsthand.

Benchmark Results:
- Single-threaded mode: ~10 operations/second
- Multi-threaded mode (10 workers): ~100 operations/second
- Performance improvement: 10×


Objectives

The project aims to show us and help us understand the differences between process vs thread, as well as demonstrate the creation of threads. Beyond basic threading concepts, this project implements a real client-server architecture where the performance benefits of multi-threading become measurable and visible. It simulates real-world banking scenarios where concurrent operations must be handled safely using mutex locks while maintaining high throughput.


Software Setup

Operating System: Ubuntu 20.04.6 LTS (WSL)

Development Environment:
VS Code with C/C++ extension
GCC Compiler
Makefile
Make build tool (sudo apt install build-essential)

Running the program:

Terminal 1 - Start the server:
cd /mnt/c/Users/khash/Documents/DEV/Multi-Threaded-Bank-System
make clean && make
./server

Terminal 2 - Start the client:
cd /mnt/c/Users/khash/Documents/DEV/Multi-Threaded-Bank-System
./client

Server command-line options:
./server           (multi-threaded mode, default)
./server --single  (single-threaded mode)
./server --help    (show usage)


Architecture Overview

The system uses a client-server architecture with TCP sockets:

CLIENT (client.c)
    |
    | TCP Socket (Port 8080)
    v
SERVER (server.c)
    |
    +-- Epoll Reactor (non-blocking I/O)
    |       Monitors multiple connections efficiently
    |
    +-- Thread Pool (thread_pool.c)
    |       10 worker threads with task queue
    |
    +-- Protocol Parser (protocol.c)
    |       Parses commands: CREATE, DEPOSIT, WITHDRAW, TRANSFER, BALANCE
    |
    +-- Transaction Engine (transactions.c)
            Per-account mutex locks for thread safety


Project Structure

File                        Description
---------------------------------------------------------------------------
include/bank.h              Defines Account structure with ID, balance, and 
                            per-account mutex lock
include/protocol.h          Protocol interface for command execution
include/thread_pool.h       Thread pool API declarations

src/server.c                Main server with epoll reactor, handles connections, 
                            dispatches to thread pool or processes inline 
                            based on threading mode
src/client.c                Interactive TUI client with menu, built-in stress 
                            testing for benchmarks
src/transactions.c          Core banking logic with fine-grained locking, 
                            deadlock avoidance in transfers
src/thread_pool.c           Worker thread pool with bounded circular task queue
src/protocol.c              Command parsing and execution, simulated processing delay
src/stress_client.c         Standalone stress test utility for benchmarking

Makefile                    Compiles server, client, and stress_client executables


Implementation Details by File

1. server.c - Main Server with Epoll Reactor
The server creates a TCP socket on port 8080 and uses Linux epoll for non-blocking I/O. The main event loop calls epoll_wait() to monitor multiple client connections efficiently. When data arrives, it either submits the task to the thread pool (multi-threaded mode) or processes inline (single-threaded mode). The server supports runtime mode switching via command-line flags (--single) and protocol commands. Signal handling ensures graceful shutdown on Ctrl+C.

2. client.c - Interactive TUI Client
The client connects to the server and presents a menu-driven interface for banking operations. It uses a mutex-protected send_command() function to ensure thread-safe communication. The client validates account IDs by querying the server before operations. Menu options 7 and 8 switch server modes and automatically run a built-in stress test (10 clients × 10 operations) to demonstrate throughput differences.

3. transactions.c - Core Banking Logic
This file manages the bank's account data using a global array of Account pointers. Each account has its own mutex lock for fine-grained synchronization. Key functions:
- create_account(): Allocates new account with unique ID under bank_state_lock
- deposit()/withdraw(): Lock individual account, modify balance, unlock
- transfer(): Acquires locks in ascending ID order to prevent deadlock
- get_balance(): Returns balance with proper locking

4. thread_pool.c - Worker Thread Pool
Implements a producer-consumer pattern with 10 worker threads and a bounded circular queue (1000 tasks). Workers wait on pthread_cond_wait() until tasks arrive. When the server submits a task via submit_task(), it signals pthread_cond_signal() to wake a worker. Workers execute the command via protocol.c and send responses directly to clients. Graceful shutdown broadcasts to all waiting threads.

5. protocol.c - Command Parser and Executor
Parses text commands (CREATE, DEPOSIT, WITHDRAW, TRANSFER, BALANCE) into a structured format. The execute_command() function routes parsed commands to the appropriate transaction functions and formats responses. A 100ms simulated delay (usleep) represents real-world latency like database access. Also handles MODE_SINGLE and MODE_MULTI commands to switch threading modes at runtime.


Testing Strategy

The following tests ensure system correctness, safety, and performance:

1. Functional Testing
- Create multiple accounts and verify unique IDs
- Deposit and withdraw valid/invalid amounts
- Transfer between accounts and verify balance integrity

2. Concurrency Testing
- Run multiple threads performing random operations
- Verify that total balance across all accounts remains constant
- Use menu option 7 (single-threaded) vs option 8 (multi-threaded) to compare throughput

3. Stress Testing
- Use built-in stress test (10 clients × 10 operations)
- Observe throughput difference: ~10 ops/sec (single) vs ~100 ops/sec (multi)
- Run standalone stress_client for extended testing

4. Synchronization Validation
- Verify mutex locks prevent race conditions
- Test deadlock avoidance in concurrent transfers
- Confirm no data corruption under heavy load

5. Error Handling Tests
- Invalid input (non-numeric or negative amounts)
- Invalid account IDs
- Exceeding maximum number of accounts


Conclusion

This project demonstrates a hands-on, real-world implementation of important operating systems concepts such as processes, threads, mutex locks, race conditions, and synchronization. Unlike simple threading exercises, this implementation shows the measurable performance benefits of multi-threading in a client-server context—achieving 10× throughput improvement with parallel processing.

The project bridges theoretical OS topics with practical system programming, implementing:
- Network communication with TCP sockets
- Non-blocking I/O with epoll
- Thread pool architecture with producer-consumer pattern
- Fine-grained locking with deadlock avoidance

This forms a strong foundation for understanding why multi-threading matters in real systems where latency is unavoidable and throughput is critical.
